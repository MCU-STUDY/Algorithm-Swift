import Foundation

/// Stack: í›„ì…ì„ ì¶œ(Last In First Out)ì˜ LIFO(ë¦¬í¬ë¼ê³  í•˜ëŠ”ê±°ê°™ìŒ) ìë£Œêµ¬ì¡°
/// ê¸°ë³¸ì ìœ¼ë¡œ Swiftì—ì„ ì€ Stackì„ Arrayë¡œ êµ¬í˜„í•  ìˆ˜ ìˆìŒ
///
/// Stackì˜ í•„ìˆ˜ì—°ì‚°ì
/// 1. push : ë§ê·¸ëŒ€ë¡œ stackì— elementë¥¼ ë„£ì–´ì£¼ëŠ” ì—°ì‚°(ë§¨ìœ„ë¡œ ì˜¬ë¼ê°)
/// 2. pop : ë§ê·¸ëŒ€ë¡œ stackì— elementë¥¼ ì œê±°í•´ì£¼ëŠ” ì—°ì‚°(ë§¨ìœ„ì—ìˆëŠ”ê±¸ ì œê±°í•´ì¤Œ)
///
/// Stackì˜ ë¹„í•„ìˆ˜ì—°ì‚°ì
/// 1. peak : stackì˜ ë§¨ ìœ„ì—ìˆëŠ” elementë¥¼ ì œê±°í•˜ì§€ì•Šê³  ì¶œë ¥í•´ì£¼ëŠ” ì—°ì‚°
/// 2. isEmpty : stackì´ ë¹„ì–´ìˆëŠ”ì§€ë¥¼ bool typeìœ¼ë¡œ ë°˜í™˜í•´ì£¼ëŠ” ì—°ì‚°
/// 3. count : stackì˜ elementê°¯ìˆ˜ë¥¼ ë°˜í™˜í•´ì£¼ëŠ” ì—°ì‚°

/// 1.êµ³ì´ classë¡œ í•´ê°€ë©´ì„œ heapì˜ì—­ì„ ë‚­ë¹„í•  í•„ìš”ê°€ ì—†ìŒ -> ìƒì†ë°›ì„ì¼ì´ ì „í˜€ì—†ìŒ
/// 2. stackì—ëŠ” intê°€ ë“¤ì–´ê°ˆìˆ˜ë„ stringì´ ë“¤ì–´ê°ˆìˆ˜ë„ìˆê¸°ë•Œë¬¸ì—(í•˜ì§€ë§Œ ë“¤ì–´ê°€ëŠ” íƒ€ì…ì€ í•œê°€ì§€ë¡œ í†µì¼, ìƒì„±ì‹œì ì— ì •í•´ì§) genericì„ ì‚¬ìš©
struct Stack<T> {
    /// ê¸°ë³¸ stackêµ¬í˜„ì¸ë° ì™¸ë¶€ì—ì„œ ì ‘ê·¼í•˜ë©´ì•ˆë˜ê¸°ë•Œë¬¸ì— privateìœ¼ë¡œ ì„ ì–¸í•´ì¤Œ
    private var stack: [T] = []
    
    /// structëŠ” ê¸°ë³¸ì ìœ¼ë¡œ initalizeë¥¼ ì œê³µí•´ì¤Œ ì•„ë˜ ì½”ë“œëŠ” êµ³ì´ í•„ìš”ì—†ìŒ
    // init() {}
    
    /// 1.í•„ìˆ˜ì—°ì‚°ì push êµ¬í˜„
    /// ìš°ì„  ì²˜ìŒë“  ìƒê°ì€ ë¬´ì¡°ê±´ elementê°€ ë“¤ì–´ê°€ëŠ”ê²Œ ê°€ì¥ë§ˆì§€ë§‰ì— ë“¤ì–´ê°€ëŠ”ê±°ë‹ˆê¹Œ listì˜ appendë¥¼ ì“°ë©´ë˜ì§€ì•Šì„ê¹Œ...?
    /// Swiftì˜ Value Type ì€ ê¸°ë³¸ì ìœ¼ë¡œ ë‚´ë¶€ì—ì„œ ì¸ìŠ¤í„´ìŠ¤ ë©”ì„œë“œë¥¼ í†µí•´ ë‚´ë¶€ ê°’ì„ ìˆ˜ì •í•  ìˆ˜ ì—†ëŠ”ë° mutatingí‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ë©´ ê°€ëŠ¥
    /// â­ï¸mutatingí‚¤ì›Œë“œëŠ” ë©”ì„œë“œì— ë¶™ëŠ” í‚¤ì›Œë“œì„ ê³„ì‚°ì†ì„±(í•¨ìˆ˜ì²˜ëŸ¼ ë™ì‘í•˜ì§€ë§Œ í•¨ìˆ˜ëŠ”ì•„ë‹˜)ì—ì„œëŠ” ì‚¬ìš© ë¶ˆê°€â­ï¸
    /// ğŸ”¥mutatingí‚¤ì›Œë“œ ê³µë¶€í•´ì„œ ì •ë¦¬í•˜ê¸°(COWì™€ í•¨ê»˜)ğŸ”¥
    mutating func push(_ element: T) {
        self.stack.append(element)
    }
    
    /// 2.í•„ìˆ˜ì—°ì‚°ì pop êµ¬í˜„
    /// mutatingí‚¤ì›Œë“œ í•„ìš”, ë§ˆì§€ë§‰ê±¸ ë¹¼ëŠ” ë©”ì„œë“œ í•„ìš”
    mutating func pop() -> T? {
        /// "." ì°ê³  ì°¾ì•„ë³´ë‹ˆ ë‘ê°€ì§€ ë©”ì„œë“œê°€ ì¡´ì¬í•˜ëŠ”ë° popLastëŠ” element?ë¥¼ ë°˜í™˜í•´ì£¼ê³  removeLastëŠ” elementë¥¼ ë°˜í™˜í•´ì¤€ë‹¤
        /// ì¦‰, removeLastë¥¼ ì‚¬ìš©í•˜ê²Œë˜ë©´ í˜¹ì—¬ë‚˜ ê·¸ ìˆœê°„ listê°€ emptyì¸ ìƒíƒœë¼ë©´ nilì„ ë°˜í™˜í•´ì¤€ë‹¤ëŠ” ë¶„ê¸°ì²˜ë¦¬ê°€ ë” í•„ìš”í•¨(êµ³ì´?)
        /// ë‘í•¨ìˆ˜ëª¨ë‘ ì„¤ëª…ë€ì— "Removes and returns the last element of the collection."ë¼ê³  ì í˜€ìˆëŠ”ê±¸ë¡œë³´ì•„ ì œê±°í›„ ì œê±°í•œê±° ì¶œë ¥í•´ì¤Œ
        // self.stack.removeLast()
        self.stack.popLast()
    }
    
    /// 3.ë¹„í•„ìˆ˜ì—°ì‚°ì peak
    /// êµ³ì´ í•¨ìˆ˜ë¡œë§Œë“¤í•„ìš”ì—†ê² ë‹¤ ì‹¶ì—ˆìŒ
    var peak: T? {
        self.stack.last
    }
    
    /// 4.ë¹„í•„ìˆ˜ì—°ì‚°ì isEmpty
    var isEmpty: Bool {
        self.stack.isEmpty
    }
    
    /// 5.ë¹„í•„ìˆ˜ì—°ì‚°ì count
    var count: Int {
        self.stack.count
    }
}

var exampleStack = Stack<Int>()

exampleStack.push(1) // [1]
exampleStack.push(3) // [1,3]
exampleStack.peak    // 3, [1,3]
exampleStack.pop()   // 3, [1]
exampleStack.isEmpty // false
exampleStack.count   // 1

print(exampleStack)  // [1]

